<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Turing Machine Editor</title>
<style>
  :root {
    --bg: #000;
    --text: #fff;
    --accent: #d4af37;
  }

@font-face {
  font-family: 'OSPDIN';
  src: url('OSPDINDIN.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
}


  body {
font-family: 'OSPDIN', 'DIN Next', 'DIN Alternate', 'DIN Condensed',
             'Franklin Gothic Medium', 'Segoe UI', 'Roboto', 'Helvetica Neue',
             Arial, sans-serif;
    background-color: var(--bg);
    color: var(--text);
    margin: 0;
    padding: 2rem;
  }

  h1 {
    text-transform: uppercase;
    font-weight: normal;
    letter-spacing: 1px;
    font-size: 2.5em;
    margin: 0 0 0.5rem 0;
  }

  #versionInfo {
    font-size: 1rem;
    color: var(--accent);
    margin-bottom: 1rem;
  }

  #midiError {
    color: white;
    font-weight: bold;
    margin-bottom: 2rem;
    display: none;
    font-size: 2em;

  }

  #midiError a {
  color: #ffffff; /* or any color you like */
  text-decoration: underline; /* optional: adds underline */
  }

  .config-grid {
    display: grid;
    grid-template-columns: auto repeat(var(--preset-count, 2), 1fr);
    gap: 2rem;
  }

  .grid-header,
  .field-label {
    text-transform: uppercase;
    font-weight: bold;
    font-size: 1.25em;
  }

  .field-label {
    border-left: 4px solid var(--accent);
    padding-left: 1rem;
  }

  .field-cell {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
  }

  button {
    font-family: 'OSP-DIN', sans-serif;
    font-size: 1.2em;
    background-color: var(--bg);
    color: var(--text);
    border: 2px solid var(--accent);
    padding: 0.7em 1.2em;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
  }

  button:hover {
    background-color: #111;
  }

  button.active {
    background-color: var(--text);
    color: var(--bg);
    border-color: var(--text);
  }



  /* --- Visualizer block styles --- */

  .visualizer-area {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    margin-bottom: 2rem;
  }

  .top-bar {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    flex-wrap: wrap;
    gap: 2rem;
    margin-bottom: 2rem;
    width: 100%;
  }

  .title-block {
    flex: 1;
    min-width: 200px;
  }

  .visualizer-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto;
    gap: 0;
    align-items: start;
    justify-items: end;
  grid-column: 2;
  }

  .visualizer {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    padding: 0.5rem 1rem;
    position: relative;
  }

  /* Vertical line between columns */
  .visualizer:nth-child(2),
  .visualizer:nth-child(4) {
    border-left: 1px solid var(--accent);
  }

  /* Horizontal line between rows */
  .visualizer:nth-child(3),
  .visualizer:nth-child(4) {
    border-top: 1px solid var(--accent);
  }

  .visualizer-label {
    text-align: center;
    margin-bottom: 0.25rem;
    font-weight: bold;
  }

  .visualizer .bits {
    display: flex;
    gap: 2px;
    justify-content: center;
    margin-bottom: 0.5rem;
  }

  .visualizer .bit {
    width: 13px;
    height: 13px;
    background: black;
    display: inline-block;
    border-radius: 50%;
  }

  .page-layout {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  .main-layout {
    display: flex;
    align-items: flex-start;
    gap: 2rem;
    flex-wrap: wrap;
  }

  .config-side {
    flex: 1 1 600px;
    min-width: 300px;
  }
  
  .page-footer {
  margin-top: 4rem;            /* space from content above */
  padding: 1rem 0;
  border-top: 1px solid var(--accent);
  text-align: left;
  font-size: 1.5em;
  color: var(--text);
}

.page-footer a {
  color: var(--accent);
  text-decoration: none;
}

.page-footer a:hover {
  text-decoration: underline;
}

  
  @media (max-width: 450px)
{
    body { padding: 1rem;}
    .config-grid {gap: 1.4rem 0.7rem;}
    button { padding: 0.4em 0.6em; }
    .field-cell {gap: 0.3rem;}
    visualiser { padding: 0.5em 0.9em;}
    .field-label {padding-left: 0.7rem;}
}
x
  
  </style>
</head>
<body>
  <div class="page-layout">
    <div class="top-bar">
      <div class="title-block">
        <h1>Turing Machine Editor</h1>
        <p id="versionInfo">Loading version info...</p>
      </div>
      <div id="visualizerContainer" class="visualizer-container"></div>
    </div>
    <div id="midiError">
      <p>Can't find or connect to a MIDI device</p>
      <ul>
        <li>Check you have a USB-C cable connecting your computer with the Computer USB-C port</li>
        <li>If you have an old version of the MIDI card, <a href="https://www.musicthing.co.uk/web_config/turing.html">try using the old editor</a>.
        </li>
        <li>If you have the latest version of the MIDI card, try cycling power off and on, then refreshing the browser.</li>
        <li>This config page is only tested in Chrome, although other Web MIDI compatible browsers</li>
        <li>Ensure you've <a href="https://support.google.com/chrome/answer/14871962">given permission to access MIDI</a>.
        </li>
      </ul>
    </div>
    <div id="config" class="config-grid"></div>
  </div>
  
  
  <footer class="page-footer">
  <p>
    <a href="https://www.musicthing.co.uk/">Music Thing Modular</a> |
    <a href="https://www.musicthing.co.uk/workshopsystem/">Workshop System</a> |
    <a href="https://www.musicthing.co.uk/Computer_Program_Cards/">Computer</a>
  </p>
</footer>

  
  
  
  <script>
  const presets = [
    { name: "Scale", key: "scale", labels: ["Chrom", "Major", "Minor", "Minor Pent", "Dorian", "Pelog", "Wholetone"], repeat: 2 },
    { name: "Octave Range", key: "range", labels: ["1", "2", "3", "4"], repeat: 2 },
    { name: "Note Length", key: "notelen", labels: ["Blip", "25%", "50%", "75%", "Full", "← → Short", "← → Long"], repeat: 2 },
    { name: "Loop Length", key: "looplen", labels: ["Ch.2 is one step shorter", "Ch.2 = Ch.1"], repeat: 2 },
    { name: "Pulse 1 Mode", key: "pulseMode1", labels: ["Clock", "Turing"], repeat: 2 },
    { name: "Pulse 2 Mode", key: "pulseMode2", labels: ["Clock", "Turing"], repeat: 2 },
    { name: "Audio/CV <br>Output Range", key: "cvRange", labels: [ "+/-6V", "+/-3V", "+6V",  "+3V"], repeat: 2 }
  ];

  const EDITOR_MAJOR_VERSION = 0x00;
  const EDITOR_MINOR_VERSION = 0x01;
  const EDITOR_POINT_VERSION = 0x01;

    const  SYSEX_START = 0xF0;
    const  SYSEX_END = 0xF7;
    const  MANU_ID = 0x7D;
    const  CARD_NUMBER = 0x03; // Card 03 = Turing Machine
    const CMD_SEND_CONFIG = 0x01; 
    const CMD_RECEIVE_CONFIG = 0X03; 



  let uiReady = false;

  let cardVersion = { major: "0", minor: "0", point: "0" }; // placeholder
  const currentValues = {};
  let midiOutput = null;


  async function getLatestReleaseVersion(repoOwner, repoName) {
  const url = `https://api.github.com/repos/${repoOwner}/${repoName}/releases/latest`;

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
    
    const data = await response.json();
    return data.tag_name || data.name; // often tag_name holds "v1.2.3"
  } catch (error) {
    console.error('Failed to fetch release info:', error);
    return null;
  }
  }





  async function initMIDI() {
    try {
      const access = await navigator.requestMIDIAccess({ sysex: true });

      access.onstatechange = () => updateMIDIDeviceStatus(access);
      updateMIDIDeviceStatus(access);

      access.inputs.forEach(input => {
        input.onmidimessage = handleMIDIMessage;
      });

      if (midiOutput) {
        sendConfigRequest();
      }
    } catch (err) {
      console.error("Failed to access Web MIDI:", err);
      document.getElementById("midiError").textContent = "MIDI access denied or unavailable. You may be using a browser (such as Safari) that doesn't support web MIDI";
      document.getElementById("midiError").style.display = "block";
      document.getElementById("config").style.display = "none";
    }
  }

  function updateMIDIDeviceStatus(access) {
    const outputs = [...access.outputs.values()];
    const errorEl = document.getElementById("midiError");
    const configEl = document.getElementById("config");

    if (outputs.length === 0) {
      midiOutput = null;
      errorEl.style.display = "block";
      configEl.style.display = "none";
    } else {
      const previouslyDisconnected = !midiOutput;
      
      for (var i=0; i<outputs.length; i++)
{
    if (outputs[i].name.includes("MTMComputer"))
    {
        midiOutput = outputs[i];
        break;
    }
}

      
      errorEl.style.display = "none";
      configEl.style.display = "grid";
      if (previouslyDisconnected) sendConfigRequest();
    }
  }

  function sendConfigRequest() {
    if (!midiOutput) return;
    const msg = [SYSEX_START, MANU_ID, CARD_NUMBER, CMD_SEND_CONFIG, SYSEX_END];
    console.log("Sending config request:", hexArray(msg));
    midiOutput.send(msg);
  }

  function sendFullConfig() {
    if (!midiOutput) return;
    const raw = getConfigBytes();
    const payload = encode7BitSysex(raw);
    const msg = [SYSEX_START, MANU_ID, CARD_NUMBER, CMD_RECEIVE_CONFIG, ...payload, SYSEX_END];
    console.log("Sending full config:", hexArray(msg));
    midiOutput.send(msg);
  }

  function getConfigBytes() {
    const HEADER_SIZE = 8;

    const maxPresets = Math.max(...presets.map(p => p.repeat || 1));
    // Total fields = sum of repeats across settings (each repeat = one byte)
    const TOTAL_FIELDS = presets.reduce((sum, s) => sum + (s.repeat || 1), 0);
    const CONFIG_SIZE = HEADER_SIZE + TOTAL_FIELDS;
    const buf = new Uint8Array(CONFIG_SIZE);
    const view = new DataView(buf.buffer);
    view.setUint32(0, 0x434F4E46, true); // MAGIC NUMBER CONF
    view.setUint16(4, 1605, true); // BPM - write blank then overwrite on arrival at device 
    buf[6] = 5; // Divide - should be removed from here 
    buf[7] = 0; // CV range - should be removed from here 

    let i = 8;
    for (let p = 0; p < 2; p++) {
      for (const setting of presets) {
        if (p < setting.repeat) {
          const field = `preset${p}.${setting.key}`;
          buf[i++] = currentValues[field] || 0;
        }
      }
    }
    return buf;
  }

  function encode7BitSysex(data) {
    const encoded = [];
    for (let i = 0; i < data.length; i += 7) {
      let msb = 0;
      const block = [];
      for (let j = 0; j < 7; j++) {
        let byte = data[i + j] || 0;
        if (byte & 0x80) msb |= (1 << j);
        block.push(byte & 0x7F);
      }
      encoded.push(msb, ...block);
    }
    return encoded;
  }

  function decode7BitSysex(data) {
    const result = [];
    for (let i = 0; i < data.length;) {
      const msb = data[i++];
      for (let j = 0; j < 7 && i < data.length; j++) {
        let b = data[i++];
        if (msb & (1 << j)) b |= 0x80;
        result.push(b);
      }
    }
    return result;
  }

  function handleMIDIMessage(e) {
    const d = [...e.data];
    if (d[0] !== SYSEX_START || d[1] !== MANU_ID || d[2] !== 0x03 || d[d.length - 1] !== SYSEX_END) return;


  console.log("this is the data:", hexArray(d));

    const command = d[3];
    
    if (command === 0x02) {

  cardVersion = {
    major: d[4],
    minor: d[5],
    point: d[6]
  }

    const payload = d.slice(7, d.length - 1); // Start payload AFTER cardversion 

    console.log("handling entire message:", hexArray(d));
    console.log("handling payload:", hexArray(payload));
      const decoded = decode7BitSysex(payload);
          console.log("decoded payload:", hexArray(decoded));
      applyConfig(decoded);
  displayVersionInfo();
      
      
    } else if (command === 0x10) {

  const payload = d.slice(4, d.length - 1); // Start payload after header  
      handleStatusMessage(payload);
    }
  }

  function applyConfig(data) {
    if (!uiReady) {
      setTimeout(() => applyConfig(data), 50);
      return;
    }

    const offset = 8;
    let i = offset;
    const maxPresets = Math.max(...presets.map(p => p.repeat || 1));
    for (let p = 0; p < maxPresets; p++) {
      for (const setting of presets) {
        if (p < setting.repeat) {
          const field = `preset${p}.${setting.key}`;
          currentValues[field] = data[i++];
        }
      }
    }
    updateUI();
  }

  function sendUpdate(field, value) {
    currentValues[field] = value;
    updateUI();
    sendFullConfig();
  }

      function hexArray(arr) {
      return arr.map(x => x.toString(16).padStart(2, "0")).join(" ");
    }

  function updateUI() {
    document.querySelectorAll("button").forEach(btn => {
      const field = btn.dataset.field;
      const value = parseInt(btn.dataset.value);
      btn.classList.toggle("active", currentValues[field] === value);
    });
  }

  function buildConfigUI() {
    const container = document.getElementById("config");
    const maxPresets = Math.max(...presets.map(p => p.repeat || 1));
    document.documentElement.style.setProperty("--preset-count", maxPresets);

    container.appendChild(document.createElement("div"));
    for (let i = 0; i < maxPresets; i++) {
      const header = document.createElement("div");
      header.className = "grid-header";
      header.textContent = i === 0 ? "Switch Mid" : "Switch Up";
      container.appendChild(header);
    }

    presets.forEach(setting => {
      const label = document.createElement("div");
      label.className = "field-label";
      label.innerHTML = setting.name;
      container.appendChild(label);

      for (let i = 0; i < maxPresets; i++) {
        const cell = document.createElement("div");
        cell.className = "field-cell";

        if (i < setting.repeat) {
          const fieldName = `preset${i}.${setting.key}`;
          setting.labels.forEach((labelText, valueIndex) => {
            const btn = document.createElement("button");
            btn.innerText = labelText;
            btn.dataset.field = fieldName;
            btn.dataset.value = valueIndex;
            btn.onclick = () => sendUpdate(fieldName, valueIndex);
            cell.appendChild(btn);
          });
        }
        container.appendChild(cell);
      }
    });
  }

  const visualizers = [];


  function setupLiveStatusVisualizers() {
  const container = document.createElement("div");
  container.className = "visualizer-container";

  const visualizerLabels = ["CV/Audio 1", "CV/Audio 2", "CV 1", "CV 2"];

  for (let i = 0; i < 4; i++) {
    const vizEl = document.createElement("div");
    vizEl.className = "visualizer";

    // Create label element
    const label = document.createElement("div");
    label.className = "visualizer-label";
    label.textContent = visualizerLabels[i];

    // Use innerHTML for rest of visualizer layout
    vizEl.innerHTML = `
      <div class="bits" id="bits-${i}"></div>
      <svg id="sparkline-${i}" viewBox="0 0 104 40" preserveAspectRatio="none">
        <g id="baseline-${i}"></g>
        <g id="sparkline-path-${i}"></g>
      </svg>
    `;

    // Re-insert label at the top *after* innerHTML (which would overwrite it otherwise)
    vizEl.insertBefore(label, vizEl.firstChild);

    container.appendChild(vizEl);

    setTimeout(() => {
      visualizers.push(createVisualizer(i, i < 2));
    }, 0);
  }


  const visualizerContainer = document.getElementById("visualizerContainer");
  visualizerContainer.appendChild(container);



  }

  function createVisualizer(index, bipolar = false) {
    const bitContainer = document.getElementById(`bits-${index}`);
    const pathContainer = document.getElementById(`sparkline-path-${index}`);
    const baselineContainer = document.getElementById(`baseline-${index}`);
    const bits = [];
    for (let i = 0; i < 8; i++) {
      const bit = document.createElement('div');
      bit.className = 'bit';
      bitContainer.appendChild(bit);
      bits.push(bit);
    }

    const history = new Array(32).fill(0);
    const w = 104;
    const h = 40;
    const step = w / 31;
    const baselineY = bipolar ? h - ((127 / 255) * h) : h;
    const baselinePath = document.createElementNS("http://www.w3.org/2000/svg", "line");
    baselinePath.setAttribute("x1", "0");
    baselinePath.setAttribute("x2", w);
    baselinePath.setAttribute("y1", baselineY);
    baselinePath.setAttribute("y2", baselineY);
    baselinePath.setAttribute("stroke", "#555");
    baselinePath.setAttribute("stroke-width", "1");
    baselinePath.setAttribute("stroke-dasharray", "2,2");
    baselineContainer.appendChild(baselinePath);

    function drawBits(val) {
      for (let i = 0; i < 8; i++) {
        const isSet = (val & (1 << (7 - i))) !== 0;
        bits[i].style.background = isSet ? 'red' : 'black';
      }
    }

    function drawSparkline() {
      pathContainer.innerHTML = '';
      for (let i = 0; i < 31; i++) {
        const v1 = history[i];
        const v2 = history[i + 1];
        const x1 = i * step;
        const x2 = (i + 1) * step;
        const y1 = h - (v1 / 255) * h;
        const y2 = h - (v2 / 255) * h;
        const fade = i / 31;
        const gray = Math.round(fade * 255);
        const color = `rgb(${gray},${gray},${gray})`;

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("stroke", color);
        path.setAttribute("stroke-width", "2");
        path.setAttribute("fill", "none");
        path.setAttribute("d", `M${x1},${y1} H${x2} V${y2}`);
        pathContainer.appendChild(path);
      }
    }

    function update(val) {
      history.push(val);
      if (history.length > 32) history.shift();
      drawBits(val);
      drawSparkline();
    }

    return { update };
  }

  function handleStatusMessage(payload) {
    if (payload.length < 11) return;
    const values = [
      (payload[0] << 7) | payload[1],
      (payload[2] << 7) | payload[3],
      (payload[4] << 7) | payload[5],
      (payload[6] << 7) | payload[7],
      payload[8],
      payload[9],
      payload[10]
    ];
    

    visualizers[0].update(values[0]);
    visualizers[1].update(values[1]);
    visualizers[2].update(values[2]);
    visualizers[3].update(values[3]);
  }

  async function displayVersionInfo() {
  const editorVersion = `${EDITOR_MAJOR_VERSION}.${EDITOR_MINOR_VERSION}.${EDITOR_POINT_VERSION}`;
  const card = `${cardVersion.major}.${cardVersion.minor}.${cardVersion.point}`;
  const versionText = `Editor v${editorVersion} — Program Card v${card}`;
  const statusSpan = document.createElement("span");

  let latestVersion = [0, 0, 0];

  try {
    const response = await fetch("https://api.github.com/repos/TomWhitwell/Smith-Kakehashi/releases/latest");
    if (response.ok) {
      const data = await response.json();
      const tag = data.tag_name || "";
      const match = tag.match(/v?(\d+)\.(\d+)\.(\d+)/);
      if (match) {
        latestVersion = [
          parseInt(match[1], 10),
          parseInt(match[2], 10),
          parseInt(match[3], 10)
        ];
      }
    } else {
      console.warn("Could not fetch latest version:", response.status);
    }
  } catch (err) {
    console.error("Error fetching latest release:", err);
  }

  const current = [
    parseInt(cardVersion.major),
    parseInt(cardVersion.minor),
    parseInt(cardVersion.point)
  ];

  let isUpgradeAvailable = false;
  for (let i = 0; i < 3; i++) {
    if (current[i] < latestVersion[i]) {
      isUpgradeAvailable = true;
      break;
    } else if (current[i] > latestVersion[i]) {
      break;
    }
  }

  if (isUpgradeAvailable) {
    statusSpan.innerHTML = ` <a href="http://www.musicthing.co.uk/latest/" target="_blank" style="background-color: red; color: white; padding: 0.1em 0.4em; border-radius: 0.2em; text-decoration: none; font-weight: bold; margin-left: 0.5em;">UPGRADE AVAILABLE</a>`;
  } else {
    statusSpan.innerHTML = ` <span style="background-color: limegreen; color: black; padding: 0.1em 0.4em; border-radius: 0.2em; font-weight: bold; margin-left: 0.5em;">LATEST</span>`;
  }

  const info = document.getElementById("versionInfo");
  info.textContent = versionText;
  info.appendChild(statusSpan);
  }

  // === Initialization ===
  buildConfigUI();
  uiReady = true;
  setupLiveStatusVisualizers();
  initMIDI();

  // 
  //   getLatestReleaseVersion('TomWhitwell', 'Smith-Kakehashi')
  //   .then(version => {
  //     if (version) {
  //       console.log('Latest version:', version);
  //     } else {
  //       console.log('Could not retrieve version info');
  //     }
  //   });
  // 





  </script>
</body>
</html>
